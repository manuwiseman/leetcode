1. classic backsak problem, we found the target we are looking for, and we know the base case (dp[0] = true), for each num, dp[i] = dp[i - num] || dp[i], and we need to go backwards in the for loop, below is the explanation:


1. The essence of using 1D dp is the we must start backward. In Approach 3, we are using the result of previous row. IIn Approach 4, since we are using single row, if you start from front, you are changing the previous values without calculating the current values.
We are using dp[j - curr] value to calculate value of current j. Eg, if j = 4, curr = 2.
You are using value of dp[2] {j-curr} to calculate value of dp[4] (j). So if you change value of dp[2] before calculating value of dp[4], it would be wrong.
Hence, you have to start from back in 1D dp solution.


因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。