so the better solution is more efficient than mine, reason is obvious (after I checked the better solution of course): we should only take combinations that's in ascending order in the final results, and my algorithm will waste a lot of time trying to form a duplicate array and then will rule it out by saying if (list.size() > 0 && list.get(list.size() - 1) > i) continue;, so the better solution simply and elegantly avoid this by setting the next backtracking start from next index ;) ok, better solution wins, easily.